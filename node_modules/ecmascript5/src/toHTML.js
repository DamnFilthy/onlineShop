(function(){
	var Lex = require('./Lex');
	var textSwap = {
		'<': '&lt;',
		'>': '&gt;',
		'&': '&amp;'
	};
	function textReplacer (c) {
		return textSwap[c];
	}
	function cleanText (text) {
		return text.replace(/[<>&]/g, textReplacer);
	}
	function cleanLines (text) {
		return text.
			replace(/\n/g, '</br>').
			replace(/\t/g, '<span class="tab">&nbsp;</span>').
			replace(/\s/g, '&nbsp;');
	}
	function makeCode (name, text, doc) {
		var span = (doc || document).createElement('span');
		span.className = 'syntax ' + name;
		span.innerHTML = text;
		return span;
	}
	function getIdentityClass (text) {
		return 'identity' +
			exports.config.identityClass[text] ? ' ' + exports.config.identityClass[text] : '';
	}
	function getPunctuatorClass (text) {
		return 'identity' +
			exports.config.punctuatorClass[text] ? ' ' + exports.config.punctuatorClass[text] : '';
	}
	exports.config = {
		name: 'jsCode',
		identityClass: {
			'var': 'green',
			'void': 'green',
			'function': 'green',
			'undefined': 'blue',
			'null': 'blue',
			'this': 'blue',
			'true': 'blue',
			'false': 'blue',
			'Infinity': 'blue',
			'NaN': 'blue',
			'if': 'orange',
			'else': 'orange',
			'return': 'orange',
			'switch': 'orange',
			'case': 'orange',
			'break': 'orange',
			'continue': 'orange',
			'delete': 'orange',
			'new': 'orange',
			'for': 'orange',
			'in': 'orange',
			'do': 'orange',
			'try': 'orange',
			'while': 'orange',
			'catch': 'orange',
			'throw': 'orange',
			'instanceof': 'orange',
			'typeof': 'orange',
			'debugger': 'orange',
			'arguments': 'yellow',
			'eval': 'yellow'
		},
		punctuatorClass: {
			'=': 'orange',
			'==': 'orange',
			'===': 'orange',
			'+=': 'orange',
			'-=': 'orange',
			'*=': 'orange',
			'/=': 'orange',
			'%=': 'orange',
			'&=': 'orange',
			'|=': 'orange',
			'^=': 'orange',
			'<=': 'orange',
			'>=': 'orange',
			'<<=': 'orange',
			'>>=': 'orange',
			'>>>=': 'orange',
			'<': 'orange',
			'>': 'orange',
			'<<': 'orange',
			'>>': 'orange',
			'>>>': 'orange',
			'~': 'orange',
			'^': 'orange',
			'|': 'orange',
			'||': 'orange',
			'&': 'orange',
			'&&': 'orange',
			'+': 'orange',
			'++': 'orange',
			'-': 'orange',
			'--': 'orange',
			'*': 'orange',
			'/': 'orange',
			'%': 'orange',
			'!': 'orange',
			'!=': 'orange',
			'!==': 'orange'
		}
	};
	exports.fromSource = function (source, code, doc) {
		return this.fromTokens(new Lex(source).tokenize().tokens, code, doc);
	};
	exports.fromTokens = function (tokens, code, doc) {
		code = code || (doc || document).createElement('div');
		var token,
		    end = tokens && tokens.length || 0,
		    ind = 0;
		code.className = this.config.name;
		for (; ind < end; ind += 1) {
			token = tokens[ind];
			if (token.type === 'comment') {
				if (token.text.charAt(1) === '/') {
					code.appendChild(makeCode('comment inline', cleanText(token.text)));
				} else {
					code.appendChild(makeCode('comment block', cleanLines(cleanText(token.text))));
				}
			} else if (token.type === 'white') {
				code.appendChild(makeCode(
					token.text === '\t' ? 'white tab' : 'white',
					token.text === '\t' ? '<pre>&#09;</pre>' : '&nbsp;'
				));
			} else if (token.type === 'line') {
				code.appendChild(makeCode('line', '</br>'));
			} else if (token.type === 'punctuator') {
				code.appendChild(makeCode(getPunctuatorClass(token.text), cleanText(token.text)));
			} else if (token.type === 'identity') {
				code.appendChild(makeCode(getIdentityClass(token.text), cleanText(token.text)));
			} else if (token.type === 'number' || token.type === 'string') {
				code.appendChild(makeCode(token.type, cleanText(token.raw)));
			} else {
				code.appendChild(makeCode(token.type, cleanText(token.text)));
			}
		}
		return code;
	};
}).call(this);