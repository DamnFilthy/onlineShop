/*global require module*/
/*
(function(){"use strict";
	function Parse () {return this.initParse();}
	var installSymbols = require('./Parse/installSymbols'),
	    Symbol = Parse.Symbol = require('./Parse/Symbol'),
	    Scope = Parse.Scope = require('./Parse/Scope'),
	    Parse_ = Parse._ = function Parse_ () {return this;},
	    parse = Parse_.prototype = Parse.prototype;
	Parse.check = function (obj) {
		return obj && obj.initParse === parse.initParse;
	};
	Parse.create = function (obj, args) {
		obj = obj || new Parse_();
		obj.initParse = parse.initParse || function () {
			return this.installSymbols().empty();
		};
		obj.empty = function () {
			this.warnings = [];
			this.syntax = [];
			this.errors = [];
			return this;
		};
		obj.parse = function (tokens) {
			this.line = 0;
			this.index = 0;
			this.tokens = tokens;
			delete this.scope;
			this.newScope();
			this.advance();
			this.stmts(this.syntax);
			this.advance('(end)');
			delete this.index;
			delete this.tokens;
			return this;
		};
		obj.stmts = function (list, power) {
			list = list || [];
			if (!list.type) {
				list.type = 'statements';
			}
			while (!this.config.endProgram[this.token.symbol.id]) {
				this.stmt(list, power);
			}
			return list;
		};
		obj.stmt = function (list, power) {
			var tok = this.token,
			    stmt;
			if (tok.symbol.has('statement')) {
				this.advance();
				stmt = tok.symbol.statement(tok);
			} else {
				stmt = this.exprs(tok, power);
				this.advance(';');
			}
			if (list && list !== stmt) {
				list.push(stmt);
			}
			return stmt;
		};
		obj.names = function (list, fn) {
			list = list || [];
			if (!list.type) {
				list.type = 'names';
			}
			var tok;
			while (!this.config.endStatement[this.token.symbol.id]) {
				if (this.token.symbol.id !== '(identity)') {
					this.error('Expected an identity name for name list.', this.token);
					break;
				}
				tok = this.token;
				this.advance();
				if (typeof fn === 'function') {
					tok = fn.call(this, tok, list) || tok;
				}
				if (list && list !== tok) {
					list.push(tok);
				}
				if (this.token.symbol.id !== ',') {
					break;
				}
				this.advance(',');
			}
			return list;
		};
		obj.pathlist = function (list) {
			list = list || [];
			if (!list.type) {
				list.type = 'pathlist';
			}
			while (!this.config.endStatement[this.token.symbol.id]) {
				list.push(this.path([]));
				if (this.token.symbol.id !== ',') {
					break;
				}
				this.advance(',');
			}
			return list;
		};
		obj.path = function (list) {
			list = list || [];
			if (!list.type) {
				list.type = 'path';
			}
			while (!this.config.endExpression[this.token.symbol.id]) {
				if (!this.isIdentity()) {
					this.error('Expected an identity name for path segment.', this.token);
					break;
				}
				list.push(this.token);
				this.advance();
				if (this.token.symbol.id !== '.') {
					break;
				}
				this.advance('.');
			}
			return list;
		};
		obj.proc = function (tok, offset, powerA, powerB) {
			var args = false;
			offset = offset || 0;
			if (this.token.symbol.id === '(') {
				this.advance('(');
				this.newScope();
				args = true;
				tok[0 + offset] = this.exprs(null, powerA || 10);
				this.advance(')');
			}
			if (this.token.symbol.id === '{') {
				this.block(tok, 1 + offset, powerB);
			}
			if (args) this.scope.pop();
			return tok;
		};
		obj.block = function (tok, index, power) {
			this.advance('{');
			this.newScope();
			tok[index || 0] = this.stmts(null, power);
			this.advance('}');
			this.scope.pop();
			return tok;
		};
		obj.exprs = function (list, power) {
			list = list || [];
			if (!list.type) {
				list.type = 'expressions';
			}
			var expr;
			while (!this.config.endStatement[this.token.symbol.id]) {
				expr = this.expr(power);
				if (expr && expr !== list) {
					list.push(expr);
				}
				if (this.token.symbol.id !== ',') {
					break;
				}
				this.advance(',');
			}
			return list;
		};
		obj.expr = function (power) {
			power = power || 0;
			var tok = this.token,
			    left;
			this.advance();
			left = tok.symbol.prefix(tok);
			while (power < this.token.symbol.power) {
				tok = this.token;
				this.advance();
				left = tok.symbol.infix(tok, left);
			}
			return left;
		};
		obj.newScope = function () {
			return new Parse.Scope(this);
		};
		obj.newSymbol = function (id) {
			return new Parse.Symbol(this, id);
		};
		obj.newToken = function (type, value, symbol) {
			var t = [];
			t.type = type;
			t.text = value;
			t.line = this.line;
			t.symbol = symbol;
			this.token = t;
			return this;
		};
		obj.itself = function (tok) {
			return tok;
		};
		obj.advance = function (id, _skip) {
			if (this.index >= this.tokens.length) {
				if (this.token.type === 'end') return this;
				return this.newToken('end', '', this.symbols['(end)']);
			}
			var config = this.config,
			    symbol = this.token && this.token.symbol,
			    type = this.token && this.token.type;
			if (type === 'line') this.line += 1;
			if (id && symbol && symbol.id !== id) {
				if (config.delim[id] && config.skip[this.tokens[this.index].type]) {
					return this;
				} else {
					this.index += 1;
					return this.error('Expected: ' + id, this.token).advance(id);
				}
			}
			this.token = this.tokens[this.index];
			type = this.token.type;
			if (config.skip[type]) {
				this.index += 1;
				return this.advance(id);
			}
			symbol = this.token.symbol = this.symbols[this.token.text];
			if (type === 'punctuator') {
				if (!symbol) {
					this.index += 1;
					return this.error('Unknown punctuator.', this.token).advance(id);
				}
			} else if (type === 'identity') {
				if (!symbol) {
					this.token.scope = this.scope;
					this.token.symbol = this.symbols['(identity)'];
				} else {
					this.token.type = 'statement';
				}
			} else if (config.literal[type]) {
				this.token.type = 'literal';
				this.token.symbol = this.symbols['(literal)'];
			} else {
				this.index += 1;
				return this.error('Unexpected token.', this.token).advance(id);
			}
			this.index += 1;
			return this;
		};
		obj.error = function (err, tok) {
			tok = tok || this.token;
			if (!tok.errors) {
				//debugger;
				tok.errors = [err];
				this.errors.push(tok);
			} else {
				tok.errors.push(err);
			}
			return this;
		};
		obj.warn = function (warn, tok) {
			tok = tok || this.token;
			if (!tok.warnings) {
				tok.warnings = [warn];
				this.warnings.push(tok);
			} else {
				tok.warnings.push(warn);
			}
			return this;
		};
		obj.isIdentity = function (tok) {
			tok = tok || this.token;
			var text = tok.text,
			    id = tok.symbol.id;
			return (text === 'self' || text === 'this' || text === 'super' || id === '(identity)');
		};
		obj.installSymbols = installSymbols;
		obj.config = {
			skip: {white: true, comment: true, line: true},
			delim: {';': true, ',': true, '}': true},
			literal: {string: true, number: true, regex: true},
			endProgram: {'}': true, '(end)': true},
			endStatement: {';': true, '}': true, '(end)': true},
			endExpression: {',': true, ';': true, '}': true, '(end)': true}
		};
		if (args) obj.initParse.apply(obj, args);
		return obj;
	};
	(module.exports = Parse).create(parse);
}).call(this);
*/